export const posts = [
  {
    id: 1,
    title: "웹 렌더링의 미래",
    excerpt: "CSR에서 ISR로의 전환과 모던 웹 앱에서의 엣지 컴퓨팅의 부상에 대해 탐구합니다.",
    content: `
      <p>웹 렌더링 기술은 지난 10년 동안 급격하게 발전했습니다. 초기 정적 사이트에서 시작하여 SPA(Single Page Application)의 시대를 거쳐, 이제는 다시 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)의 장점을 결합한 하이브리드 모델로 나아가고 있습니다.</p>
      
      <h3>CSR의 한계</h3>
      <p>클라이언트 사이드 렌더링(CSR)은 풍부한 상호작용을 제공하지만, 초기 로딩 속도와 SEO(검색 엔진 최적화) 측면에서 약점을 가지고 있습니다. 사용자의 기기 성능에 의존적이라는 점도 무시할 수 없는 문제입니다.</p>

      <h3>ISR과 엣지 컴퓨팅</h3>
      <p>Incremental Static Regeneration(ISR)은 정적 페이지의 빠른 속도를 유지하면서도, 데이터가 변경되었을 때 백그라운드에서 페이지를 갱신할 수 있게 해줍니다. 여기에 엣지 컴퓨팅(Edge Computing)이 더해지면, 사용자와 가장 가까운 서버에서 콘텐츠를 제공하여 지연 시간을 최소화할 수 있습니다.</p>

      <p>결국 미래의 웹은 <strong>"필요한 순간에, 가장 가까운 곳에서, 최적의 형태로"</strong> 렌더링되는 방향으로 진화할 것입니다.</p>
    `,
    tags: ["Performance", "Architecture"],
    date: "2025. 12. 02"
  },
  {
    id: 2,
    title: "CSS Grid & Subgrid 마스터하기",
    excerpt: "복잡한 레이아웃과 서브그리드가 컴포넌트 디자인을 어떻게 변화시키는지 깊이 있게 다룹니다.",
    content: `
      <p>CSS Grid는 웹 레이아웃의 혁명과도 같았습니다. 하지만 중첩된 컴포넌트 구조에서 부모 그리드의 트랙을 자식 요소가 공유하지 못하는 한계가 있었죠. 여기서 등장한 것이 바로 <strong>Subgrid</strong>입니다.</p>

      <h3>Subgrid가 해결하는 문제</h3>
      <p>Subgrid를 사용하면 자식 요소가 부모의 그리드 트랙을 그대로 상속받을 수 있습니다. 이는 카드 UI나 복잡한 대시보드 레이아웃을 만들 때, 서로 다른 컨테이너에 있는 요소들의 줄을 완벽하게 맞출 수 있게 해줍니다.</p>

      <p>이제 디자이너가 의도한 그리드 시스템을 코드 상에서도 완벽하게 구현할 수 있는 시대가 되었습니다.</p>
    `,
    tags: ["CSS", "Design"],
    date: "2025. 11. 28"
  },
  {
    id: 3,
    title: "내가 Rust로 전향한 이유",
    excerpt: "가비지 컬렉션 없는 메모리 안전성? 시스템 프로그래밍을 위한 나의 Rust 학습기.",
    content: `
      <p>오랫동안 C++과 JavaScript를 사용해왔지만, Rust를 처음 접했을 때의 충격은 잊을 수 없습니다. 컴파일러가 메모리 안전성을 보장해준다는 개념은 처음엔 낯설었지만, 곧 강력한 무기가 되었습니다.</p>

      <h3>소유권(Ownership) 모델</h3>
      <p>Rust의 핵심인 소유권 모델은 가비지 컬렉터(GC) 없이도 메모리 누수를 방지합니다. 이는 예측 가능한 성능이 필요한 시스템 프로그래밍에서 엄청난 이점을 제공합니다.</p>

      <p>물론 러닝 커브는 가파릅니다. 하지만 그 산을 넘었을 때 얻게 되는 안정성과 성능은 그 모든 노력을 보상하고도 남습니다.</p>
    `,
    tags: ["Rust", "Systems"],
    date: "2025. 11. 15"
  },
  {
    id: 4,
    title: "인터랙티브 UI 패턴",
    excerpt: "사용자 참여와 유지율을 높이는 즐거운 마이크로 인터랙션 만들기.",
    content: `
      <p>사용자는 단순히 정보를 소비하는 것을 넘어, 제품과 '대화'하기를 원합니다. 버튼을 눌렀을 때의 미세한 반동, 스크롤에 따라 부드럽게 움직이는 요소들은 사용자에게 "이 시스템은 살아있다"는 느낌을 줍니다.</p>
      
      <p>좋은 마이크로 인터랙션은 사용자의 행동에 대한 즉각적인 피드백을 제공하고, 수행 중인 작업의 상태를 직관적으로 알려줍니다. 이는 결과적으로 사용자 경험(UX)을 크게 향상시킵니다.</p>
    `,
    tags: ["UX", "Animation"],
    date: "2025. 11. 10"
  },
  {
    id: 5,
    title: "코드 에디터와 AI",
    excerpt: "LLM이 우리가 매일 코드를 작성하고, 디버깅하고, 배포하는 방식을 어떻게 변화시키고 있는지.",
    content: `
      <p>Copilot과 같은 AI 도구의 등장은 개발자의 생산성을 획기적으로 높였습니다. 이제 우리는 보일러플레이트 코드를 작성하는 데 시간을 낭비할 필요가 없습니다.</p>
      
      <p>하지만 AI는 도구일 뿐입니다. 중요한 것은 AI가 생성한 코드를 검증하고, 전체 아키텍처를 설계하는 개발자의 역량입니다. AI 시대에 개발자의 역할은 '코더(Coder)'에서 '아키텍트(Architect)'로 변화하고 있습니다.</p>
    `,
    tags: ["AI", "Productivity"],
    date: "2025. 10. 30"
  },
  {
    id: 6,
    title: "2025년의 상태 관리",
    excerpt: "아직도 Redux가 필요할까요? Signals, Atoms, 그리고 상태 관리의 미래를 살펴봅니다.",
    content: `
      <p>Redux는 훌륭하지만, 너무 많은 보일러플레이트를 요구했습니다. 최근에는 Recoil, Jotai와 같은 Atomic 패턴이나, Vue와 SolidJS에서 영감을 받은 Signals 패턴이 주목받고 있습니다.</p>
      
      <p>이러한 새로운 도구들은 상태 관리를 더 직관적이고 세밀하게(Fine-grained) 만들어줍니다. 컴포넌트의 불필요한 리렌더링을 줄이고, 개발자 경험(DX)을 개선하는 것이 2025년 상태 관리의 핵심 트렌드입니다.</p>
    `,
    tags: ["JavaScript", "React"],
    date: "2025. 10. 22"
  }
];
